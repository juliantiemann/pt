var string = require('string'); // load string.js first to avoid https://github.com/jprichardson/string.js/issues/160
var _ = require('lodash');
var fs = require('fs');
var path = require('path');
var lame = require('lame');
var wav = require('wav');
/*eslint-env node*/

//------------------------------------------------------------------------------
// node.js starter application for Bluemix
//------------------------------------------------------------------------------

// This application uses express as its web server
// for more info, see: http://expressjs.com
var express = require('express');

// cfenv provides access to your Cloud Foundry environment
// for more info, see: https://www.npmjs.com/package/cfenv
var cfenv = require('cfenv');
var appEnv = cfenv.getAppEnv();
// local environment extend
try {
  var services = JSON.parse(require('fs').readFileSync('./env.json', 'utf8'), true);
  _.extend(appEnv, services)
} catch(e) {}

// create a new express server
var multer  = require('multer')

var storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, './uploads/');
  },
  filename: function (req, file, cb) {
    if(file.mimetype == "image/jpeg") {
      cb(null, Date.now() + '-' + file.originalname + ".jpg");
    } else if(file.mimetype == "image/png") {
      cb(null, Date.now() + '-' + file.originalname + ".png");
    }
  }
});

var upload = multer({ storage: storage });

var express 	= require('express');
var app     	= express();
var	ibmbluemix 	= require('ibmbluemix');
var	config  	= {
	// change to real application route assigned for your application
	applicationRoute : "http://cake-translate.eu-gb.mybluemix.net",
	// change to real application ID generated by Bluemix for your application
	applicationId : appEnv.app.application_id
};

var AlchemyAPI = require('./lib/alchemyapi');
var alchemyapi = new AlchemyAPI(appEnv.services.alchemy_api[0].credentials.apikey);

var watson = require('watson-developer-cloud');
var fs = require('fs');

/* This could be read from environment variables on Bluemix */
var visual_recognition = watson.visual_recognition({
  username: appEnv.services.visual_recognition[0].credentials.username,
  password: appEnv.services.visual_recognition[0].credentials.password,
  version: 'v1-beta'
  // version: 'v2-beta',
  // version_date:'2015-12-02'
});

var text_to_speech = watson.text_to_speech({
  version: 'v1',
  username: appEnv.services.text_to_speech[0].credentials.username,
  password: appEnv.services.text_to_speech[0].credentials.password
});

var google_translate = require('google-translate')(appEnv.services["user-provided"][0].credentials.access_key);

// init core sdk
ibmbluemix.initialize(config);
var logger = ibmbluemix.getLogger();


// CORS (Cross-Origin Resource Sharing) headers to support Cross-site HTTP requests
app.all('*', function(req, res, next) {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");
  next();
});

if(!appEnv.isLocal) {
  app.use(function requireHTTPS(req, res, next) {
    console.log(req.secure);
    if((!req.secure) && (req.get('X-Forwarded-Proto') !== 'https')) {
      res.redirect('https://' + req.get('Host') + req.url);
    } else {
      next();
    }
  });
}

//redirect to cloudcode doc page when accessing the root context
app.get('/', function(req, res){
  res.sendFile(path.resolve(__dirname, 'public/www/index.html'));
});

app.get('/env', function(req, res) {
  res.json(appEnv);
  // res.json(cfenv.getAppEnv({"name": "cake-translate-server"}));
})

app.get('/voice', function(req, res){
  var filename = req.query.text.replace(/\s+/g, '-').toLowerCase();
  fs.stat(path.resolve(__dirname, "audio/" + filename + ".mp3"), function(err) {
    if(!err) {
      res.sendFile(path.resolve(__dirname, "audio/" + filename + ".mp3"));
    } else {
      var transcript = text_to_speech.synthesize({text: req.query.text, voice:'de-DE_BirgitVoice', accept: 'audio/wav'});
      var reader = new wav.Reader();
      var output = fs.createWriteStream("audio/" + filename + ".mp3");
      transcript.pipe(reader);
      reader.on('format', function(format) {
        var encoder = new lame.Encoder(format);
        // one could call .pipe(res) as well to send it directly
        reader.pipe(encoder).pipe(output);
      });
      output.on('finish', function() {
        res.sendFile(path.resolve(__dirname, "audio/" + filename + ".mp3"));
      });
    }
  });
});


app.post('/uploadpic', upload.single("file"), function(req, result) {
  var imgFile;

  if (req.file) {
    // file image
    imgFile = fs.createReadStream(req.file.path);
  } else if(req.body.url && validator.isURL(req.body.url)) {
    // web image
    imgFile = request(req.body.url.split('?')[0]);
  } else if (req.body.url && req.body.url.indexOf('images') === 0) {
    // local image
    imgFile = fs.createReadStream(path.join('public', req.body.url));
  } else {
    // malformed url
    return result.json({ error: 'Malformed URL', code: 400 });
  }

  var stats = fs.statSync(req.file.path);
  var fileSizeInBytes = stats["size"]
  //Convert the file size to megabytes (optional)
  var fileSizeInMegabytes = fileSizeInBytes / 1000000.0

  var labels = {"labels":[], "size":fileSizeInMegabytes};

  var watsonRequest = new Promise(function(resolve, reject) {
    var formData = {
      image_file: imgFile
    };
    visual_recognition.recognize(formData, function(err, res) {
      // delete the recognized file
      // if(req.file)
      //   fs.unlink(imgFile.path);
      if (err) {
  			reject(err);
  		} else {
  			resolve(res.images[0]);
  		}
    });
  })
  .then(function(res) {
    console.log("Watson Success");
    res["labels"].forEach(function(entry) {
      labels.labels.push({"label_source": "watson", "label_name": entry["label_name"], "label_score": entry["label_score"]});
    });
  })
  .catch(function(err) {
    console.log("Watson Error");
    console.log(err);
  });

  var alchemyRequest = new Promise(function(resolve, reject) {
    alchemyapi.image_keywords('image', req.file.path, {}, function(response) {
      resolve(response);
  	}, function(err) {
      reject(err);
    });
  })
  .then(function(res) {
    console.log("Alchemy Success");
    // results["alchemy"] = res;
    res["imageKeywords"].forEach(function(entry) {
      labels.labels.push({"label_source": "alchemy", "label_name": entry.text, "label_score": entry.score});
    });
  })
  .catch(function(err) {
    console.log("Alchemy Error");
    console.log(err);
  });

  Promise.all([watsonRequest,alchemyRequest])
  .then(function() {
    console.log("All Promises Success");

    if(req.file) {
      try {
        fs.unlink(imgFile.path);
      } catch(e) {}
    }
    texts_source = _.map(labels.labels, function(label) { return label.label_name; });

    google_translate.translate(texts_source, 'en', 'de', function(err, translations) {
      if (err) {
  			// reject(err);
  		} else {
        _.each(translations, function(translation) {
          _.find(labels.labels, {'label_name': translation.originalText}).label_name = translation.translatedText;
        });
        result.json(labels);
      }
    });
  })
  .catch(function(err) {
    console.log("All Promises Error");
    console.log(err); // some coding error in handling happened
    result.json(labels);
  });

});

// init service sdks
// app.use(function(req, res, next) {
//     req.logger = logger;
//     next();
// });
app.use(express.static(__dirname + '/public'));
app.use('/js', express.static(__dirname + '/public/www/js'));
app.use('/css', express.static(__dirname + '/public/www/css'));
app.use('/img', express.static(__dirname + '/public/www/img'));
app.use('/lib', express.static(__dirname + '/public/www/lib'));
app.use('/templates', express.static(__dirname + '/public/www/templates'));
app.use('/bower_components', express.static(__dirname + '/public/www/bower_components'));


// init basics for an express app
app.use(require('./lib/setup'));

var ibmconfig = ibmbluemix.getConfig();

logger.info('mbaas context root: '+ibmconfig.getContextRoot());
// "Require" modules and files containing endpoints and apply the routes to our application
app.use(ibmconfig.getContextRoot(), require('./lib/staticfile'));

// app.listen(ibmconfig.getPort());
app.listen(appEnv.port, appEnv.bind, function() {
  console.log("server starting on " + appEnv.url)
})
logger.info('Server started at port: '+ibmconfig.getPort());
